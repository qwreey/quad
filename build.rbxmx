<roblox version="4">
  <Item class="ModuleScript" referent="0">
    <Properties>
      <string name="Name">Plugin</string>
      <string name="Name">quad</string>
      <string name="Source"><![CDATA[local module = {};

-- TODO : style should be can edited with anytimes, and the object's styles can be changed (add, remove ...)
--        and also, styles can be affect by the objects sorts
--[[
this feature should be like :

local style_all = style {
  BackgroundTransparency = 0.2;
}

frame{
  Size = UDim2.new(1,0,1,0);
  textBox "#Input" {
    [event.property "Text"] = function (this,text)
      print(this,"의 글자가",text,"로 변경됨");
    end;
  };
  [style.set] = {
		style_all
	};
};

]]

function module.init()
	local this = {items = {}};

	local event = require(script.event).init(this); if false then event = require("src.event").init(this); end
	local class = require(script.class).init(this); if false then class = require("src.class").init(this); end
	local store = require(script.store).init(this); if false then store = require("src.store").init(this); end
	local style = require(script.style).init(this); if false then style = require("src.style").init(this); end

	this.event = event;
	this.class = class;
	this.store = store;
	this.style = style;
	--this.makeClass = makeClass;
	--this.tween = tween;
	--this.plugin = plugin;

	return this;
end

return module;
]]></string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">class</string>
        <string name="Source">local module = {};

function module.init(shared)
	local new = {};
	local bind = shared.event.bind;
	local items = shared.items;

	function new.make(ClassName,prop)
		-- make thing
		local item;
		local classOfClassName = type(ClassName);
		if classOfClassName == "string" then
			item = Instance.new(ClassName);
		elseif classOfClassName == "function" then
			item = ClassName();
		elseif classOfClassName == "table" then
			local func = ClassName.new or ClassName.New or ClassName.__new;
			item = func();
		end
		if not item then
			local str = tostring(ClassName);
			print(("fail to make item '%s', did you forget to checking the class '%s' is exist?"):format(str,str));
		end

		-- set property and adding child and binding functions
		for index,value in pairs(prop) do
			local valueType = typeof(value);
			local indexType = typeof(index);

			-- child
			if indexType ~= "string" then -- object
				value.Parent = new;
			elseif valueType == "function" and bind(value) then -- connect event
			elseif indexType == "string" then
				new[index] = value; -- set property
			end
		end
		return item;
	end
	local make = new.make;

	function new.import(ClassName)
		return function (prop)
			if type(prop) == "string" then
				local lastName = prop;
				return function (nprop)
					nprop.Name = lastName;
					local item = make(ClassName,nprop);
					items[lastName] = item;
					return item;
				end;
			end
			return make(ClassName,prop);
		end;
	end

	setmetatable(new,{
		__call = function (self,...)
			return self.import(...);
		end;
	});

	return new;
end

return module;</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="2">
      <Properties>
        <string name="Name">event</string>
        <string name="Source">local module = {};

function module.init(shared)
	local new = {};
	local unpack = table.unpack;
	local coroutineCreate = coroutine.create;
	local coroutineResume = coroutine.resume;

	local prefix = "event::";
	local special = {
		["Property::(.+)"] = function (this,func,property)
			this.GetPropertyChangedSignal(property):Connect(function()
				func(this,this[property]);
			end);
		end;
		["CreatedSync::"] = function (this,func)
			func(this);
		end;
		["Created::"] = function (this,func)
			coroutineResume(coroutineCreate(func),this);
		end;
	};

	local prefixLen = #prefix;
	setmetatable(new,{
		__call = function(self,eventName)
			return prefix .. eventName;
		end;
	});

	-- try binding, if key dose match with anything, ignore call
	function new.bind(this,key,func)
		-- check prefix
		if key:sub(1,prefixLen) ~= prefix then
			return;
		end
		key = key:sub(prefixLen + 1,-1);

		-- find special bindings
		for specKey,specFunc in pairs(special) do
			local find = {key:match(specKey)};
			if #find ~= 0 then
				specFunc(this,func,unpack(find));
				return true;
			end
		end

		-- binding normal events
		local event = this[key];
		if event then
			event:Connect(function(...)
				func(this,...);
			end);
			return true;
		end
	end

	-- property changed binding
	local prefixProperty = prefix .. "Property::";
	function new.property(name)
		return prefixProperty .. name;
	end

	-- when created binding
	new.created = prefix .. "Created::";
	new.createdSync = prefix .. "CreatedSync::";
	return new;
end

return module;</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="3">
      <Properties>
        <string name="Name">store</string>
        <string name="Source"><![CDATA[local module = {};

--[[
this feature allows get object without making some created callback and local var
but, it can't allows mulit id and object
this feature should be upgraded
]]

function module.init(shared)
	local new = {};
	local items = shared.items;

	function new.getObject(id)
		return items[id];
	end
	function new.setObject(id,object)
		items[id] = object;
	end
end

return module;
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="4">
      <Properties>
        <string name="Name">style</string>
        <string name="Source">local module = {};

function module.init(shared)
    local new = {};

    function shared.new()

    end

    function shared.

    return new;
end

return module;</string>
      </Properties>
    </Item>
  </Item>
</roblox>