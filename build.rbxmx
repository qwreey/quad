<roblox version="4">
  <Item class="ModuleScript" referent="0">
    <Properties>
      <string name="Name">Plugin</string>
      <string name="Name">quad</string>
      <string name="Source"><![CDATA[local module = {};

-- TODO : style should be can edited with anytimes, and the object's styles can be changed (add, remove ...)
--        and also, styles can be affect by the objects sorts
--[[
this feature should be like :

local style_all = style {
  BackgroundTransparency = 0.2;
}

frame{
  Size = UDim2.new(1,0,1,0);
  textBox "#Input" {
    [event.property "Text"] = function (this,text)
      print(this,"의 글자가",text,"로 변경됨");
    end;
  };
  [style.set] = {
		style_all
	};
};

]]

require = require(script.require);
local event = require("event");
local store = require("store");
local style = require("style");
local class = require("class");
local mount = require("mount");

function module.init()
	local this = {items = {}};

	this.event = event.init(this);
	this.store = store.init(this);
	this.style = style.init(this);
	this.class = class.init(this);
	this.mount = mount.init(this);

	--this.makeClass = makeClass;
	--this.tween = tween;
	--this.plugin = plugin;

	return this;
end

return module;
]]></string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">bind</string>
        <string name="Source"></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="2">
      <Properties>
        <string name="Name">class</string>
        <string name="Source">local module = {};

function module.init(shared)
	local new = {};
	local bind = shared.event.bind;
	local addObject = shared.store.addObject;

	function new.make(ClassName,prop)
		-- make thing
		local item;
		local classOfClassName = type(ClassName);
		if classOfClassName == "string" then -- if classname is a string value, cdall instance.new for making new roblox instance
			item = Instance.new(ClassName);
		elseif classOfClassName == "function" then -- if classname is a function value, call it for making new object (OOP object)
			item = ClassName();
		elseif classOfClassName == "table" then -- if classname is a calss what is included new function, call it for making new object (object)
			local func = ClassName.new or ClassName.New or ClassName.__new;
			item = func();
		end
		if not item then -- if cannot make new object, ignore this call
			local str = tostring(ClassName);
			print(("fail to make item '%s', did you forget to checking the class '%s' is exist?"):format(str,str));
		end

		-- set property and adding child and binding functions
		for index,value in pairs(prop) do
			local valueType = typeof(value);
			local indexType = typeof(index);

			-- child
			if indexType ~= "string" then -- object
				value.Parent = new;
			elseif valueType == "function" and bind(value) then -- connect event
			elseif indexType == "string" then
				new[index] = value; -- set property
			end
		end
		return item;
	end
	local make = new.make;

	function new.import(ClassName) -- make new quad class object
		local this = {styles = {}};
		setmetatable(this,{
			__call = function (self,prop)
				if type(prop) == "string" then
					local lastName = prop;
					return function (nprop)
						nprop.Name = lastName;
						local item = make(ClassName,nprop);
						addObject(lastName,item);
						return item;
					end;
				end
				return make(ClassName,prop);
			end;
		});
		return this;
	end

	-- set module calling function
	setmetatable(new,{
		__call = function (self,...)
			return self.import(...);
		end;
	});

	return new;
end

return module;</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="3">
      <Properties>
        <string name="Name">event</string>
        <string name="Source">local module = {};

function module.init(shared)
	local new = {};
	local unpack = table.unpack;
	local coroutineCreate = coroutine.create;
	local coroutineResume = coroutine.resume;

	local prefix = "event::";
	local special = {
		["Property::(.+)"] = function (this,func,property)
			this.GetPropertyChangedSignal(property):Connect(function()
				func(this,this[property]);
			end);
		end;
		["CreatedSync::"] = function (this,func)
			func(this);
		end;
		["Created::"] = function (this,func)
			coroutineResume(coroutineCreate(func),this);
		end;
	};

	local prefixLen = #prefix;
	setmetatable(new,{
		__call = function(self,eventName)
			return prefix .. eventName;
		end;
	});

	-- try binding, if key dose match with anything, ignore call
	function new.bind(this,key,func)
		-- check prefix
		if key:sub(1,prefixLen) ~= prefix then
			return;
		end
		key = key:sub(prefixLen + 1,-1);

		-- find special bindings
		for specKey,specFunc in pairs(special) do
			local find = {key:match(specKey)};
			if #find ~= 0 then
				specFunc(this,func,unpack(find));
				return true;
			end
		end

		-- binding normal events
		local event = this[key];
		if event then
			event:Connect(function(...)
				func(this,...);
			end);
			return true;
		end
	end

	-- property changed binding
	local prefixProperty = prefix .. "Property::";
	function new.property(name)
		return prefixProperty .. name;
	end

	-- when created binding
	new.created = prefix .. "Created::";
	new.createdSync = prefix .. "CreatedSync::";
	return new;
end

return module;</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="4">
      <Properties>
        <string name="Name">mount</string>
        <string name="Source">local module = {};

function module.init(shared)
    local new = {};

    -- we should add plugin support
    function new.mount(to,this)
        this.Parent = to;
    end

    setmetatable(new,{
        __call = function (self,...)
            self.mount(...);
        end;
    });

    return new;
end

return module;</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="5">
      <Properties>
        <string name="Name">require</string>
        <string name="Source">-- remove the roblox's require system,
-- now, we can call modules with string path

if (not workspace) and (not game) and (not script) then
    return;
end

return function (query)
    local typeQuery = type(query);

    if typeQuery == "string" then
        local object = script.Parent;
        query = query:gsub("/",".");
        -- local index = 0;
        query:gsub("[^%.]+",function (this)
            -- index = index + 1;
            -- if index == 1 and this == "src" then
            --     return;
            -- end
            local lastObject = object;
            object = object[this];
            if not object then
                object = lastObject.libs
                error(("[require] : object %s was not found from this worktree, require failed"):format(query));
            end
        end);
        return require(object);
    elseif typeQuery == "userdata" then
        return require(query);
    end
end;</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="6">
      <Properties>
        <string name="Name">store</string>
        <string name="Source"><![CDATA[local module = {};

--[[
this feature allows get object without making some created callback and local var
but, it can't allows mulit id and object
this feature should be upgraded
]]

local insert = table.insert;
function module.init(shared)
	local new = {};
	local items = shared.items;

	function new.getObjects(id)
		return items[id];
	end
	function new.addObject(id,object)
		local array = items[id];
		if not array then
			array = {};
			items[id] = array;
		end
		insert(array, object);
	end

	return new;
end

return module;
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="7">
      <Properties>
        <string name="Name">style</string>
        <string name="Source">local module = {};

function module.init(shared)
    local new = {};

    function shared.new(property)

    end

    return new;
end

return module;</string>
      </Properties>
    </Item>
  </Item>
</roblox>